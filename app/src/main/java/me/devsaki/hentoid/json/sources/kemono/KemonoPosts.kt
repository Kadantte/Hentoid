package me.devsaki.hentoid.json.sources.kemono

import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass
import me.devsaki.hentoid.database.domains.Attribute
import me.devsaki.hentoid.database.domains.AttributeMap
import me.devsaki.hentoid.database.domains.Chapter
import me.devsaki.hentoid.database.domains.Content
import me.devsaki.hentoid.enums.AttributeType
import me.devsaki.hentoid.enums.Site
import me.devsaki.hentoid.enums.StatusContent
import me.devsaki.hentoid.parsers.cleanup
import me.devsaki.hentoid.parsers.urlsToImageFiles
import me.devsaki.hentoid.util.image.isSupportedImage

/**
 * Kemono posts generated by calling the "posts-legacy" API endpoint
 * (contains way more data that the "posts" endpoint but allows to map all pictures in one pass)
 */
@JsonClass(generateAdapter = true)
data class KemonoPosts(
    val props: Properties,
    val results: List<Post>,
    @Json(name = "result_previews")
    val previews: List<List<KemonoAttachment>>
) {
    @JsonClass(generateAdapter = true)
    data class Properties(
        val id: String,
        val service: String,
        val name: String
    )

    @JsonClass(generateAdapter = true)
    data class Post(
        val id: String,
        val user: String,
        val service: String,
        val title: String,
        val published: String?,
        val tags: List<String>?,
        val file: KemonoAttachment?,
        val attachments: List<KemonoAttachment>
    )

    fun update(content: Content, galleryUrl: String): Content {
        content.site = Site.KEMONO
        content.url = galleryUrl.replace("/api/v1/", "/")
        content.title = cleanup(props.name)
        content.status = StatusContent.SAVED
        content.uploadDate = 0L

        val attributes = AttributeMap()
        attributes.add(
            Attribute(
                AttributeType.ARTIST,
                props.name,
                "https://kemono.su/${props.service}/user/${props.id}",
                Site.KEMONO
            )
        )
        content.putAttributes(attributes)

        // One result = one chapter, if it contains at least an usable picture (i.e. not exclusively MEGA links)
        val nbPagesTotal = results
            .flatMap { it.attachments }
            .filter { isSupportedImage(it.path ?: "") }
            .distinct()
            .count()
        val chapters = ArrayList<Chapter>()
        var chapterOrder = 1
        var pageOrder = 1
        results.forEachIndexed { index, result ->
            val thumbs = previews[index]
                .filter { isSupportedImage(it.path ?: "") }
                .distinct()
                .associateBy({ it.path }, { it })
            if (thumbs.isNotEmpty()) {
                val imageUrls = result.attachments
                    .filter { isSupportedImage(it.path ?: "") }
                    .distinct()
                    .map {
                        val server = thumbs[it.path]?.server ?: ""
                        "$server/data/${it.path}"
                    }
                if (imageUrls.isNotEmpty()) {
                    val chapter = Chapter(
                        chapterOrder++,
                        "https://kemono.su/${props.service}/user/${props.id}/post/${result.id}",
                        result.title
                    )
                    val imageFiles = urlsToImageFiles(
                        imageUrls,
                        pageOrder,
                        StatusContent.SAVED,
                        nbPagesTotal,
                        chapter
                    )
                    pageOrder = imageFiles.maxOf { it.order } + 1
                    chapter.setImageFiles(imageFiles)
                    chapters.add(chapter)
                }
            }
        }
        content.setChapters(chapters)
        content.qtyPages = chapters.sumOf { it.imageList.size }
        content.setImageFiles(chapters.flatMap { it.imageList })

        return content
    }
}